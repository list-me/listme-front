/* eslint-disable */
import React, {
  createContext,
  useCallback,
  useEffect,
  useMemo,
  useState,
} from "react";
import { toast } from "react-toastify";

import { productRequests } from "../../services/apis/requests/product";
import { templateRequests } from "../../services/apis/requests/template";
import { ICustomCellType } from "./product.context";
import { AxiosResponse } from "axios";
import { fileRequests } from "../../services/apis/requests/file";

export interface ICustomField {
  hidden?: boolean;
  width?: string;
  frozen?: boolean;
  order?: string;
}

export interface ICustom {
  show?: boolean;
  width?: string;
  frozen?: boolean;
  order?: string;
}

interface IRelation {
  agreementType: string;
  field: string;
  mappingType: string;
  owner: string;
  templateId: string;
}
export interface IHeaderTable {
  title?: string;
  type: string;
  data: string;
  className: string;
  options: string[] | IRelation[];
  hidden?: boolean;
  width?: string;
  frozen?: boolean;
  order?: string;
}

interface ITypeProductContext {
  products: any[];
  filteredData: any[];
  filter: string | undefined;
  setProducts: Function;
  setFilteredData: Function;
  handleRedirectAndGetProducts: (template: any) => Promise<any>;
  headerTable: IHeaderTable[];
  setHeaderTable: Function;
  handleAdd: Function;
  handleSave: (value: any, isNew: boolean, productId: string) => Promise<any>;
  editing: boolean;
  setEditing: Function;
  colHeaders: string[];
  handleDelete: Function;
  COMPONENT_CELL_PER_TYPE: ICustomCellType;
  handleUpdateTemplate: Function;
  template: any;
  hidden: number[];
  handleHidden: Function;
  setHidden: Function;
  handleResize: Function;
  setColHeaders: Function;
  handleFreeze: Function;
  handleMove: Function;
  handleNewColumn: Function;
  handleFilter: Function;
  handleRemoveColumn: (
    column: number,
    fields: any[],
    newColumns: any[],
    fieldId: string,
  ) => void;
  handleGetProducts: (
    templateId: string,
    templateFields: IHeaderTable[],
  ) => Promise<any>;

  handleGetTemplate: (templateId: string) => Promise<void>;
  total: number;
  handleGetProductsFiltered: (
    key: string,
    templateId: string,
  ) => Promise<any[]>;
  uploadImages: (
    files: Array<File>,
    bucketUrl: string,
  ) => Promise<Array<string> | void>;
}

interface IField {
  id: string;
  type: string;
  group: string;
  title: string;
  options: string[];
  required: boolean;
  help_text: string;
  is_public: string;
  description: string;
  order?: string;
  hidden?: boolean;
  width?: string;
  frozen?: boolean;
  bucket_url: string;
}

interface SignedUrlResponse {
  url: string;
  access_url: string;
}

export const productContext = createContext<ITypeProductContext>({
  products: [],
  filteredData: [],
  filter: "",
  setProducts: () => {},
  setFilteredData: () => {},
  handleRedirectAndGetProducts: async (): Promise<any> => {},
  headerTable: [],
  setHeaderTable: () => {},
  handleAdd: () => {},
  handleSave: async (): Promise<any> => {},
  editing: false,
  setEditing: () => {},
  colHeaders: [],
  handleDelete: () => {},
  COMPONENT_CELL_PER_TYPE: {},
  handleUpdateTemplate: () => {},
  template: {},
  hidden: [],
  handleHidden: () => {},
  setHidden: () => {},
  handleResize: () => {},
  setColHeaders: () => {},
  handleFreeze: () => {},
  handleMove: () => {},
  handleNewColumn: () => {},
  handleFilter: () => {},
  handleRemoveColumn: () => {},
  handleGetProducts: async (): Promise<any> => {},
  handleGetTemplate: async (): Promise<void> => {},
  total: 0,
  handleGetProductsFiltered: async (
    key: string,
    templateId: string,
  ): Promise<any[]> => [],
  uploadImages: async (): Promise<void> => {},
});

export const ProductContextProvider = ({ children }: any) => {
  const [products, setProducts] = useState<any[]>([]);
  const [template, setTemplate] = useState<any>();
  const [headerTable, setHeaderTable] = useState<IHeaderTable[]>([]);
  const [colHeaders, setColHeaders] = useState<any[]>([]);
  const [editing, setEditing] = useState<boolean>(false);
  const [hidden, setHidden] = useState<any[]>([]);
  const [customFields, setCustomFields] = useState<any[]>([]);
  const [filteredData, setFilteredData] = useState<any[]>([]);
  const [filter, setFilter] = useState<string | undefined>(undefined);
  const [total, setTotal] = useState<number>(0);
  console.log(
    "ðŸš€ ~ file: index.tsx:165 ~ ProductContextProvider ~ total:",
    total,
  );

  const COMPONENT_CELL_PER_TYPE: ICustomCellType = useMemo(
    () => ({
      RADIO: "radio",
      LIST: "select",
      CHECKED: "checkbox",
      FILE: "file",
      RELATION: "relation",
    }),
    [],
  );

  async function handleGetProductsFiltered(
    keyword: string,
    templateId: string,
  ): Promise<any[]> {
    const { data } = await productRequests.list(
      { keyword, limit: 100 },
      templateId,
    );
    return data;
  }

  const getSignedUrl = async (
    fileName: string,
    fileType: string,
    templateId: string,
  ): Promise<SignedUrlResponse> => {
    return fileRequests.getSignedUrl(fileName, fileType, templateId);
  };

  const uploadImages = useCallback(
    async (files: File[], bucketUrl: string): Promise<string[] | void> => {
      try {
        const filesNames: string[] = [];
        const uploadPromises = files.map(async (file) => {
          const [fileName, fileType] = file.name.split(".");

          const signedUrl = await getSignedUrl(fileName, fileType, bucketUrl);
          filesNames.push(signedUrl.access_url);
          return fileRequests.uploadFile(file, signedUrl.url);
        });

        await Promise.all(uploadPromises);
        return filesNames;
      } catch (error) {
        console.log({ error });
        throw new Error("Ocorreu um erro ao realizar o upload dos arquivos");
      }
    },
    [],
  );

  const handleUpdateTemplate = (): void => {};

  function handleDelete(product: any): any {
    try {
      productRequests
        .delete(product.id)
        .then(() => {
          toast.success("Produto excluÃ­do com sucesso");
        })
        .catch((error) => {
          throw error;
        });
    } catch (error) {
      console.error(error);
      toast.error("Ocorreu um erro na tentativa de deletar este produto");
    }
  }

  const handleGetProducts = useCallback(
    async (
      templateId: string,
      templateFields: IHeaderTable[],
      page: number = 0,
      limit: number = 100,
    ) => {
      // if (total == prod.length) return;
      const { data } = await productRequests.list({ page, limit }, templateId);

      const productFields: any = [];
      data?.products?.forEach((item: any) => {
        const object: any = {};
        item.fields.forEach((field: any) => {
          const currentField = templateFields.find(
            (e: any) => e.data == field.id,
          );

          if (currentField && field.value) {
            const test = !COMPONENT_CELL_PER_TYPE[
              currentField?.type?.toUpperCase()
            ]
              ? field?.value[0]
              : field?.value;

            object[field?.id] = test;
          }
        });

        productFields.push({
          ...object,
          id: item.id,
          created_at: item.created_at,
        });
      });

      if (!productFields.length && template) {
        productFields.push({ [template[0]]: "" });
      }

      setProducts(productFields);
      setTotal(data?.total);
      return { products, headerTable };
    },
    [COMPONENT_CELL_PER_TYPE, headerTable, products, template],
  );

  const handleGetTemplate = useCallback(async (templateId: string) => {
    try {
      const response = await templateRequests.get(templateId);
      setTemplate(response);
      const fields = response?.fields;
      let headersCell: any[] = [];
      let headers = fields?.fields?.map((item: IField, index: any) => {
        headersCell.push(item.title);
        return {
          title: item.title,
          data: item.id,
          className: "htLeft htMiddle",
          type: item.type,
          required: item.required,
          options: item.options,
          order: item.order !== undefined ? item.order : index.toString(),
          hidden: item.hidden ? item.hidden : false,
          width: item.width ? item.width : "300px",
          frozen: item.frozen ? item.frozen : false,
          bucket_url: response?.bucket_url,
        };
      });

      const sortedHeaders = headers.sort((a: any, b: any) => {
        return Number(a.order) - Number(b.order);
      });

      const headerTitles = sortedHeaders.map((item: any) => {
        return item?.title;
      });

      headersCell = [...headerTitles, " "];
      headers = [...sortedHeaders, {}];
      setColHeaders(headersCell);
      setHeaderTable(headers);
      setHidden(
        sortedHeaders
          .filter((item: any) => item.hidden)
          .map((element: any) => Number(element.order)),
      );
      setCustomFields(
        sortedHeaders
          .filter((element: any) => Object.keys(element).length)
          .map((item: any) => {
            const { order, hidden, width, frozen, data } = item;
            return { order, hidden, width, frozen, id: data };
          }),
      );
      setFilter(undefined);
      return headers;
    } catch (error) {
      console.error(error);
      toast.error("NÃ£o foi possÃ­vel carregar o template, tente novamente!");
    }
  }, []);

  const handleRedirectAndGetProducts = useCallback(
    async (id: string) => {
      try {
        const template: IHeaderTable[] = await handleGetTemplate(id);
        const product = await handleGetProducts(id, template);
        return product;
      } catch (error) {
        console.error(error);
        toast.error(
          "Ocorreu um erro com sua solicitaÃ§Ã£o de produtos, tente novamente",
        );
      }
    },
    [handleGetProducts, handleGetTemplate],
  );

  const handlePost = useCallback(async (product: any) => {
    return productRequests.save(product);
  }, []);

  const buildProduct = useMemo(
    () => (fields: any) => {
      const obj: any[] = [];
      if (Object.keys(fields).length) {
        const columnKeys = headerTable.map((column) => column?.data);
        Object.keys(fields).forEach((field: any) => {
          if (
            fields[field] &&
            !["id", "created_at"].includes(field) &&
            columnKeys.includes(field)
          ) {
            obj.push({
              id: field,
              value:
                typeof fields[field] === "object"
                  ? fields[field]
                  : [fields[field]],
            });
          }
        });
      }

      return obj;
    },
    [headerTable],
  );

  const handleSave = useCallback(
    async (value: any, isNew: boolean, productId: string): Promise<any> => {
      try {
        const fields = buildProduct(value);

        if (isNew) {
          await productRequests.update({ id: productId, fields });
          toast.success("Produto atualizado com sucesso");
        } else {
          const newProduct = {
            id: productId,
            product_template_id: window.location.pathname.substring(10),
            is_public: true,
            fields,
          };
          let newItem;

          const product = await handlePost(newProduct);
          newItem = product.id;

          toast.success("Produto cadastrado com sucesso");
          return newItem;
        }
      } catch (error: any) {
        const message =
          typeof error?.response?.data?.message === "object"
            ? error?.response?.data?.message[0]
            : error?.response?.data?.message;

        toast.error(message);
      }
    },
    [buildProduct, handlePost],
  );

  const handleAdd = useCallback(() => {
    if (filteredData.find((product: any) => !Object.keys(product).length)) {
      toast.error("Preencha o novo produto em branco!");
      return;
    }

    setProducts((old) => [{}, ...old]);
  }, [filteredData]);

  const handleResize = useCallback(
    (col: number, newSize: number, template: any) => {
      const customs = customFields.map((item: any, index: any) => {
        if (item && item?.order === col.toString()) {
          return {
            ...item,
            width: newSize.toString(),
            order: index.toString(),
          };
        }

        return item;
      });
      setCustomFields(customs);

      templateRequests
        .customView(template.id, { fields: customs })
        .catch(() =>
          toast.error("Ocorreu um erro ao alterar o tamanho do campo"),
        );
    },
    [customFields],
  );

  const buildCustomFields = useCallback(
    (fields: any, { order, show, width, frozen }: ICustom, col: number) => {
      const testing = [...customFields];
      return testing?.map((custom) => {
        if (custom?.order == col) {
          return {
            id: custom?.id,
            order: order ? order.toString() : custom?.order,
            hidden: show !== undefined ? show : custom?.hidden,
            width: width || custom?.width,
            frozen: frozen || custom?.frozen,
          };
        }
        return custom;
      });
    },
    [customFields],
  );

  const handleHidden = useCallback(
    (col: number, template: any, able: boolean): number[] => {
      const content = hidden;
      let newValue;
      if (content.includes(col)) {
        newValue = content.filter((element) => element !== col);
      } else {
        newValue = [...content, col];
      }

      setHidden(newValue);

      const customFieldsUpdated = customFields.map((item) => {
        if (item?.order === col.toString()) {
          return {
            ...item,
            hidden: able,
          };
        }

        return item;
      });
      setCustomFields(customFieldsUpdated);

      const custom = buildCustomFields(
        template?.fields?.fields,
        { show: able },
        col,
      );

      templateRequests
        .customView(window.location.pathname.substring(10), { fields: custom })
        .catch(() =>
          toast.error("Ocorreu um erro ao alterar a visibilidade do campo"),
        );

      return newValue;
    },
    [buildCustomFields, customFields, hidden],
  );

  const handleFreeze = (col: any, state: boolean, operation?: string) => {
    let changeState: any[];
    if (operation && operation == "unfreeze") {
      changeState = customFields.map((customs) => {
        return {
          ...customs,
          frozen: false,
        };
      });

      setCustomFields(changeState);
    } else {
      changeState = customFields.map((customs) => {
        if (Number(customs?.order) <= col?.order) {
          return {
            ...customs,
            frozen: true,
          };
        }

        return customs;
      });

      setCustomFields(customFields);
    }

    setHeaderTable((prev) => {
      return prev.map((item, index) => {
        return {
          ...item,
          width: changeState[index]?.width,
          order: changeState[index]?.order,
          frozen: changeState[index]?.frozen,
          hidden: changeState[index]?.hidden,
        };
      });
    });

    templateRequests
      .customView(template.id, { fields: changeState })
      .catch((error) =>
        toast.error("Ocorreu um erro ao definir o freeze da coluna"),
      );

    return customFields;
  };

  const handleMove = (col: any[]) => {
    const fields = col
      .filter((item) => {
        if (Object.keys(item).length > 0) return item;
      })
      .map((element) => {
        return {
          order: element?.order,
          hidden: element?.hidden,
          width: element?.width,
          frozen: element?.frozen,
          id: element?.data,
        };
      });

    templateRequests
      .customView(window.location.pathname.substring(10), { fields })
      .catch(() =>
        toast.error("Ocorreu um erro ao alterar a posiÃ§Ã£o da coluna"),
      );
  };

  const handleNewColumn = useCallback(
    (col: any, fields: any[]) => {
      const newTemplate = template;
      newTemplate.fields.fields = fields;
      setTemplate(newTemplate);

      setCustomFields((prev) => [
        ...prev,
        {
          order: col?.order,
          hidden: col?.hidden,
          width: col?.width,
          frozen: col?.frozen,
          id: col?.data,
        },
      ]);

      const newPosition = [...headerTable, col];
      newPosition.splice(newPosition.length - 2, 1);
      newPosition.push({});
      setHeaderTable(newPosition);
    },
    [headerTable, template],
  );

  const handleFilter = useCallback(
    (word: string): any[] => {
      const filtered = products.filter((row) => {
        const multiOptions: string[] = [];
        let values = Object.values(row).filter((element: any) => {
          if (typeof element === "object") {
            return Object.values(element).forEach((option: any) =>
              multiOptions.push(option),
            );
          }

          return element !== undefined;
        });
        values = [...values, ...multiOptions];

        return values.some((cell) => {
          const option = cell as string;
          if (option.toLocaleLowerCase().includes(word.toLocaleLowerCase())) {
            return cell;
          }
        });
      });

      setFilteredData(filtered);
      setFilter(word === "" ? undefined : word);
      return filtered;
    },
    [products],
  );

  const handleRemoveColumn = useCallback(
    (column: number, fields: any[], newColumns: any[], fieldId: string) => {
      const newTemplate = template;
      newTemplate.fields.fields = fields;
      setTemplate(newTemplate);

      const keys = newColumns
        .filter((item) => Object.keys(item).length)
        .map((item) => item.data);
      const customs = customFields
        .filter((item) => keys.includes(item?.id))
        .map((element, index) => ({ ...element, order: index.toString() }));

      setCustomFields(customs);
      setHeaderTable(newColumns);
      templateRequests
        .removeColumn(window.location.pathname.substring(10), {
          column: fieldId,
        })
        .then(() => {
          templateRequests
            .customView(template.id, { fields: customs })
            .catch(() =>
              toast.error("Ocorreu um ao alterar os campos customizados"),
            );
        })
        .catch(() =>
          toast.error("Ocorreu um erro ao excluir a coluna do template"),
        );
    },
    [customFields, template],
  );

  const value = useMemo(
    () => ({
      products,
      filteredData,
      filter,
      setProducts,
      setFilteredData,
      handleRedirectAndGetProducts,
      headerTable,
      setHeaderTable,
      handleAdd,
      handleSave,
      editing,
      setEditing,
      colHeaders,
      handleDelete,
      COMPONENT_CELL_PER_TYPE,
      handleUpdateTemplate,
      template,
      hidden,
      total,
      handleHidden,
      setHidden,
      handleResize,
      setColHeaders,
      handleFreeze,
      handleMove,
      handleNewColumn,
      handleFilter,
      handleRemoveColumn,
      handleGetProducts,
      handleGetProductsFiltered,
      handleGetTemplate,
      uploadImages,
    }),
    [
      COMPONENT_CELL_PER_TYPE,
      colHeaders,
      editing,
      filter,
      filteredData,
      handleAdd,
      handleFilter,
      handleFreeze,
      handleGetProducts,
      handleGetTemplate,
      handleHidden,
      handleNewColumn,
      handleRedirectAndGetProducts,
      handleRemoveColumn,
      handleResize,
      handleSave,
      headerTable,
      hidden,
      products,
      template,
      total,
      uploadImages,
    ],
  );

  return (
    <productContext.Provider value={value}>{children}</productContext.Provider>
  );
};
